Python Decorators

A decorator is a special function, which takes in a function as a parameter, adds some functionality to it and returns it.

Python's decorators allow you to extend and modify the behavior of existing function without permanently modifying it.

Example of decorator: (How decorator looks like)

	@login_required
	def view_account(request):
		...
		
	def deposit(request):
		.....
		
	def deposit(request):
		.....


Decorators concept is considered as complicated to get into. To be precise, the usage of decorators is very easy, but on the other side writing decorators can be complicated task, especially if you are not experienced with decorators and some functional programming concepts.

As we have seen in definition of decorator, that 
A decorator is a special function, which takes in a function as a parameter, adds some functionality to it and returns it. 

This means that in python
	1. A function can accept be passed to another function as a parameter.
	2. A function can also return a function.
	
So, as writing a decorator can be a complex but a great learning task, we require some Prerequisite so that you can play around with decorators. Once you learn how to write decorators, you literally start playing with them: 

Prerequisite(Functional Programming):

	1. Function can be assigned to a variable.
		def func():
			....
			....
		x = func
		#####x = func()
		
	2. Function can be declared with in some function(nested function).
		def outer(): # outer function
			.....
			def inner(): # nested function
				.....
	3. Function can also return a function.
		def outer():
			.....
			def inner():
				.....
				
			return inner
	
	4. Function can be passed as an argument to another function.
		def A():
			....
			....
		def B(funct):
			.....
			....
		B(A)
		
So, we should be comfirtable with all the four concepts, then 
writing your decorator will not be a complex task. You will then try to solve 
many of your problems with decorators. Since they are very powerfull.

Now we start with first concept out of four which we have to expertize before writing decorators.

1. Function can be assigned to a variable.

Example 1: (#001.py)
----------------------
	def first():
		print("Function Assignment Example")

	first()

	second = first
	second()
	'''
	Here, the names first and second 
	refer to the same function object.
	'''
	print(first)
	print(second)
	
Output :
Function Assignment Example
Function Assignment Example
<function first at 0x7fa1f606f1f0>
<function first at 0x7fa1f606f1f0>

=====>> try second = first()
**************************************************************
Example 2: (#002.py)
----------------------
def add_numbers(x, y):
    return x+y

x = add_numbers
print(x(10, 20))
print(type(x))

Output :
30
<class 'function'>
*************************************************************
Example 3: (#003.py)
----------------------
def increment(x):
    return x + 1


successor = increment

print('successor of 10 is :', successor(10))

Output :
successor of 10 is : 11
*************************************************************

So, we have tried to assign both type of functions to a variable, i.e function
with parameters and function without parameters.

Lets move one step further and cover the topic

2. Function can be declared with in some function(nested function).
	or Function inside Function

Defining an Inner Function

To define an inner function in Python, we simply create a function inside another function using the Python's def keyword. 

Example 4: (#004.py)
----------------------
def outer():

    def inner():
        print("Hi, it's me 'inner'")
        print("Thanks for calling me")

    print("This is the function 'outer'")
    print("I am calling 'inner' now:")
    inner()


outer()

Output :
This is the function 'outer'
I am calling 'inner' now:
Hi, it's me 'inner'
Thanks for calling me
*************************************************************

In this example, inner() has been defined inside outer(), making it an inner function. To call inner(), we must first call outer(). The outer() will then go ahead and call inner() as it has been defined inside it.

It is important to mention that the outer function has to be called in order for the inner function to execute. If the outer function is not called, the inner function will never execute. To demonstrate this, modify the above code to the following and run it:

Example 5: (#005.py)
----------------------
# Delete the function call of output() in the last
def outer(): # outer function
    print ("Hello from outer function")
    def inner(): # inner function
        print ("Hello from inner function")
    inner()
Output :    
The code will return nothing when executed!
Try : 
outer.inner
outer.inner()
outer().inner
outer().inner()
***************************************************

Here is another example:
Example 6: (#006.py)
----------------------
def funct1(x, y):

   def funct2(x, y):
      print('Multiplication =', x * y)
      
   funct2(x, y)

funct1(10,20)

Output : 
Multiplication = 200
**************************************************

The code returns the multiplication of the two numbers 10 and 20 i.e 200. The example shows that an inner function is able to access variables of outer function.

So, it is possible for us to access the variables of the outer function inside the inner function. What if we attempt to change the variables of the outer function from inside the inner function? Let us see what happens:

Example 7: (#007.py)
----------------------
def function1():  # outer function
    x = 2  # A variable defined within the outer function

    def function2(a):  # inner function
       # Let's define a new variable within the inner function
       # rather than changing the value of x of the outer function
        x = 6
        print(a+x)
    
    print(x)  # to display the value of x of the outer function
    function2(3)

function1()

Output : 
2
9
**************************************************
The output shows that it is possible for us to display the value of a variable defined within the outer function from the inner function, but not change it. The statement x = 6 helped us create a new variable x inside the inner function function2() rather than changing the value of variable x defined in the outer function function1().

Lets see how can the inner function changes the values of outer function.

Example 8: (#008.py)
----------------------
def f1():
    s = ['I love java']

    def f2():
        s[0] = 'I love python'
        # try s.append('I love python')
        print(s)

    f2()
    print(s)
    
f1()
Output : 
['I love python']
['I love python']
**************************************************
Example 9: (#009.py)
----------------------

def function1():  # outer function
    x = 2  n

    def function2(a):  # inner function       
        nonlocal x
        x = 6
        print(a+x)

    function2(3) # before print x, we have to call inner function
                 # then only changes will be reflected.
    print(x)


function1()

Output : 
9
6
**************************************************
Value can also be changed as shown in the below example

Example 10: (#010.py)
----------------------
def f1():  # outer function
    f1.x = 2

    def f2(a):  # inner function        
        f1.x = 6
        print(a+f1.x)

    f2(3) 
    print(f1.x)

f1()
Output : 
9
6
**************************************************

Lets move one step further and cover the topic

3. Function can also return a function.

This is also knows as Closures and Factory Functions.

However, for the case of closures, one must use the nested functions.

The following are the conditions that are required to be met in order to create a closure in Python:

	1 There must be a nested function	
	2. The enclosing function has to return the nested function

Example 11: (#011.py)
----------------------
def outer(text):
    text = text

    def inner():
        print(text)

    return inner  # Note we are returning function WITHOUT parenthesis


funct = outer('Example of closure')
funct()

Output : 
Example of closure
**************************************************
As observed from above code, closures help to invoke function outside their scope.
The function inner function has its scope only inside the outer Function. But with the use of closures we can easily extend its scope to invoke a function outside its scope.

Inner functions help us in defining factory functions. A factory function is a function that creates another object. Look another example:

Example 12: (#012.py)
----------------------
def make_multiplier_of(n):
    def multiplier(x):
        return x * n
    return multiplier

times3 = make_multiplier_of(3)
print(times3(9))

times5 = make_multiplier_of(5)
print(times5(3))

print(times5(times3(2)))

print(times3.__closure__)
print(times3.__closure__[0].cell_contents)

Output : 
27
15
30
(<cell at 0x7feb2ffa2e20: int object at 0x94cea0>,)
3
**************************************************
Example 13: (#013.py)
----------------------
def has_permission(page):
    def inner(username):
        if username == 'Admin':
            return f"'{username}' does have access to {page}."
        else:
            return f"'{username}' does NOT have access to {page}."
    return inner


current_user = has_permission('Admin Area')
print(current_user('Admin'))

random_user = has_permission('Admin Area')
print(random_user('Not Admin'))

Output : 
'Admin' does have access to Admin Area.
'Not Admin' does NOT have access to Admin Area.
**************************************************

This is a simplified function to check if a certain user has the correct permissions to access a certain page. 

The use of closures and factory functions is the most common and powerful use for inner functions. In most cases, when you see a decorated function, the decorator is a factory function that takes a function as argument and returns a new function that includes the old function inside the closure. 

you clearly understand this when we move to function as argument.
So, in functional programming we proceed to our last step and that is

4. Function can be passed as an argument to another function.

A function can take multiple arguments, these arguments can be 
1. objects
2. variables(of same or different data types) 
3. and functions.

Due to the fact that every parameter of a function is a reference to an object and functions are objects as well therefore, we can pass functions.

Example 14: (#014.py)
----------------------
def a():
    print("Hi, it's me 'a()'")
    print("Thanks for calling me")

def b(f):
    print("Hi, it's me 'b()'")
    print("I will call 'a()' now")
    f()
    # If we need to know what the 'real' name of function
    print("func's real name is " + f.__name__)
    
b(a)

Output : 
Hi, it's me 'b()'
I will call 'a()' now
Hi, it's me 'a()'
Thanks for calling me
func's real name is a
**************************************************

I think, now we are ready to create decorators.

Decorators
-----------
Python has an interesting feature called decorators to add functionality to an existing code.

A decorator takes in a function, adds some functionality and returns it.

Example 15: (#015.py)
----------------------
def get_loaded(func):
    def inner():        
        func()
        print("I am loaded")
    return inner


@get_loaded
def rifle():
    print("T-5000 sniper rifle")


rifle()

# # let's decorate this ordinary function
# rifle = get_loaded(rifle)
# rifle()

Output : 
T-5000 sniper rifle
I am loaded
**************************************************

We can see that the decorator function added some new functionality to the original function. 
This is similar to packing a gift. The decorator acts as a wrapper. 
The nature of the object that got decorated (actual gift inside) does not alter. 
But now, it looks pretty (since it got decorated).

We use the @ symbol along with the name of the decorator function and 
place it above the definition of the function to be decorated. For example,

We can also chain the decorators

Example 16: (#016.py)
----------------------
def master_python(func):
    def python():
        func()
        print('Now Expert In Python')
    return python


def master_django(func):
    def django():
        func()
        print('Now Expert In Django')
    return django

# programmer = master_django(programmer)
# programmer = master_python(programmer)

@master_django
@master_python
def programmer():
    print('I know programming concepts')


programmer()

Output : 
I know programming concepts
Now Expert In Python
Now Expert In Django
**************************************************

Example 17: (#017.py)
----------------------
def legends(func):
    def checkker(name):
        if name == 'Mountbatten':
            print('Mountbatten Was not an indian legend')
        else:
            func(name)
    return checkker


@legends
def indian_legends(name):
    print(name, 'Was a indian legend')


indian_legends('Swami Vivekanand')
indian_legends('Mahatma Gandhi')
indian_legends('Mountbatten')
indian_legends('Aarya Bhatt')

Output : 
Swami Vivekanand Was a indian legend
Mahatma Gandhi Was a indian legend
Mountbatten Was not an indian legend
Aarya Bhatt Was a indian legend
**************************************************

Example 18: (#018.py)
----------------------
def autheticate(func):
    def inner(user):        
        if user == 'kkk':
            print('Welcome', user)
            func(user)
        else:
            print('Please Login')
    return inner


@autheticate
def login(user):
    print("You Got an Email")


login('kkk')

Output : 
Welcome kkk
You Got an Email
***********************************************


